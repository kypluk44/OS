## pipe
### `pipe` — это механизм межпроцессного взаимодействия (IPC, Inter-Process Communication).

* Он создаёт однонаправленный канал «памяти», через который один процесс может писать, а другой читать.
* На уровне ядра это буфер в памяти ядра (обычно 4–64 КБ), организованный по принципу очередь FIFO (first in – first out).
* У канала есть два конца:
    - `fd[0]` — конец для чтения
    - `fd[1]` — конец для записи

#### Как работает
1.	Если процесс пишет (write(fd[1], ...)), данные попадают в буфер ядра.
2.	Если процесс читает (read(fd[0], ...)), данные из буфера удаляются и возвращаются процессу.
3.	Если буфер переполнен:
    - write блокируется, пока кто-то не прочитает.
4.	Если буфер пуст:
    -	read блокируется, пока кто-то не запишет.
5.	Если все пишущие концы закрыты, а мы читаем — read вернёт 0 (EOF).
6.	Если все читающие концы закрыты, а мы пишем — write завершится ошибкой (SIGPIPE или -1).

## fork()

### `fork()` - системный вызов ядра Linux
* Когда процесс вызывает fork(), ядро создаёт копию текущего процесса:
    +	копируется адресное пространство (память),
    +	копируются открытые файловые дескрипторы (stdin/stdout, файлы, пайпы),
    +	копируются регистры и контекст.
* Но с одной важной деталью: это не прямой клон в памяти, а копия по принципу “copy-on-write”: пока родитель и ребёнок не меняют память, физически копий страниц нет — они общие. Как только одна сторона что-то пишет, копируется только та страница (экономия памяти).

### Возвращает 
- В родительском процессе — PID ребёнка (>0).
- В дочернем процессе — 0.
- При ошибке — -1.

## dup2(oldfd, newfd)

### `dup2` — это системный вызов для дублирования файлового дескриптора.

* В ядре все потоки (stdin=0, stdout=1, stderr=2) и открытые файлы/пайпы представлены как дескрипторы (целые числа).
* `dup2(oldfd, newfd)` заставляет `newfd` указывать на тот же объект ядра, что и oldfd.
    - Если `newfd` уже был открыт — его сначала закрывают.
    - После этого `newfd` и `oldfd` становятся «синонимами» одного канала.


## execl(path, arg0, arg1, ..., NULL)

* `exec*` — целое семейство функций. Они не создают новый процесс, а заменяют текущий процесс другим исполняемым файлом.
* `execl`
    - Загружает бинарник по пути path.
    - Загружает в память новый код и данные из указанного файла.
    - Передаёт управление новой программе, как будто она была запущена “с нуля”.
* Важное: после `execl` старый код не выполняется вообще. Если`execl` успешен — он не возвращает в программу. Если возвращает — значит ошибка (например, файла нет).